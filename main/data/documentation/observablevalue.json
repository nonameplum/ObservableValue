{"topicSections":[{"identifiers":["doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/AsyncStateStream"],"anchor":"Essentials","title":"Essentials"},{"identifiers":["doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportObservableValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportMutableObservableValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservableValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/MutableObservableValue"],"anchor":"Protocols","title":"Protocols"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/observablevalue"]}],"abstract":[{"text":"Current-value semantics for Swift concurrency: a multi-consumer async sequence that always yields the latest value—like Combine’s ","type":"text"},{"type":"codeVoice","code":"CurrentValueSubject"},{"text":", but for async\/await.","type":"text"}],"hierarchy":{"paths":[[]]},"sections":[],"schemaVersion":{"patch":0,"major":0,"minor":3},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue"},"primaryContentSections":[{"content":[{"anchor":"overview","type":"heading","text":"Overview","level":2},{"inlineContent":[{"identifier":"ObservableValue_logo","type":"image"}],"type":"paragraph"},{"anchor":"Overview","type":"heading","text":"Overview","level":2},{"inlineContent":[{"type":"text","text":"Swift’s structured concurrency lacks a built-in “current value” primitive. This package fills that gap with "},{"type":"reference","isActive":true,"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Synchronous snapshot"}]},{"text":": Read ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/value"},{"text":" at any time.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Async stream of changes","type":"text"}],"type":"strong"},{"text":": Iterate ","type":"text"},{"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/values","isActive":true,"type":"reference"},{"text":" from multiple tasks.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"No backpressure","type":"text"}]},{"type":"text","text":": Producers proceed immediately; slow consumers see the latest value."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Backportable"}]},{"text":": Works on iOS 16+ with Swift 6 toolchains.","type":"text"}],"type":"paragraph"}]}]},{"type":"codeListing","syntax":"swift","code":["import ObservableValue","","let counter = ObservedValue(0)","","\/\/ Multiple concurrent consumers","Task { for await v in counter.values { print(\"A:\", v) } }","Task { for await v in counter.values { print(\"B:\", v) } }","","\/\/ Atomic mutation","counter.update { $0 += 1 }","","\/\/ Synchronous read","print(counter.value)  \/\/ 1"]},{"anchor":"Backpressure-Semantics","type":"heading","text":"Backpressure Semantics","level":3},{"inlineContent":[{"type":"text","text":"Producers are never blocked. Each consumer sees the "},{"inlineContent":[{"type":"text","text":"latest"}],"type":"emphasis"},{"type":"text","text":" value when it resumes—intermediate values may be skipped if the consumer is slower than the producer."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let state = ObservedValue(0)","var iterator = state.values.makeAsyncIterator()","","state.update { $0 = 1 }","state.update { $0 = 2 }","state.update { $0 = 3 }","","let observed = await iterator.next()  \/\/ 3 (skipped 1, 2)"]},{"anchor":"Backport-API","type":"heading","text":"Backport API","level":3},{"inlineContent":[{"text":"On toolchains where ","type":"text"},{"code":"AsyncSequence.Failure","type":"codeVoice"},{"text":" isn’t available, use the concrete stream:","type":"text"}],"type":"paragraph"},{"code":["for await value in counter.backportValues {","    print(\"value:\", value)","}"],"type":"codeListing","syntax":"swift"}],"kind":"content"}],"kind":"symbol","metadata":{"role":"collection","title":"ObservableValue","modules":[{"name":"ObservableValue"}],"roleHeading":"Framework","externalID":"ObservableValue","symbolKind":"module"},"references":{"doc://observablevalue.ObservableValue/documentation/ObservableValue/BackportMutableObservableValue":{"abstract":[{"type":"text","text":"A backportable mutable observable value that supports atomic in-place updates."}],"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportMutableObservableValue","kind":"symbol","title":"BackportMutableObservableValue","navigatorTitle":[{"kind":"identifier","text":"BackportMutableObservableValue"}],"url":"\/documentation\/observablevalue\/backportmutableobservablevalue","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"BackportMutableObservableValue"}]},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservedValue":{"kind":"symbol","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue","navigatorTitle":[{"text":"ObservedValue","kind":"identifier"}],"role":"symbol","title":"ObservedValue","url":"\/documentation\/observablevalue\/observedvalue","abstract":[{"text":"A thread-safe container that holds a current value and broadcasts changes to multiple async consumers.","type":"text"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ObservedValue","kind":"identifier"}],"type":"topic"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/AsyncStateStream":{"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/AsyncStateStream","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncStateStream"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"AsyncStateStream"}],"abstract":[{"type":"text","text":"A non-throwing async sequence that yields the latest value from an "},{"type":"reference","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue","isActive":true},{"type":"text","text":"."}],"title":"AsyncStateStream","type":"topic","role":"symbol","url":"\/documentation\/observablevalue\/asyncstatestream"},"doc://observablevalue.ObservableValue/documentation/ObservableValue":{"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue","role":"collection","url":"\/documentation\/observablevalue","abstract":[{"text":"Current-value semantics for Swift concurrency: a multi-consumer async sequence that always yields the latest value—like Combine’s ","type":"text"},{"type":"codeVoice","code":"CurrentValueSubject"},{"text":", but for async\/await.","type":"text"}],"title":"ObservableValue","kind":"symbol","type":"topic"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservableValue":{"url":"\/documentation\/observablevalue\/observablevalue","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ObservableValue"}],"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservableValue","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ObservableValue"}],"title":"ObservableValue","abstract":[{"type":"text","text":"A read-only observable value that exposes the current snapshot and an opaque async sequence of changes."}]},"ObservableValue_logo":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/observablevalue.ObservableValue\/ObservableValue_logo.png"}],"identifier":"ObservableValue_logo","alt":"ObservableValue logo"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/BackportObservableValue":{"url":"\/documentation\/observablevalue\/backportobservablevalue","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"BackportObservableValue"}],"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportObservableValue","abstract":[{"type":"text","text":"A read-only observable value that exposes the current snapshot and a concrete stream of changes."}],"title":"BackportObservableValue","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"BackportObservableValue"}]},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservedValue/values":{"type":"topic","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/values","role":"symbol","title":"values","url":"\/documentation\/observablevalue\/observedvalue\/values","kind":"symbol","abstract":[{"text":"An async sequence of value changes.","type":"text"}],"fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"values"},{"kind":"text","text":": "},{"preciseIdentifier":"s:15ObservableValue16AsyncStateStreamV","kind":"typeIdentifier","text":"AsyncStateStream"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:15ObservableValue08ObservedB0C0B0xmfp","kind":"typeIdentifier","text":"Value"},{"kind":"text","text":">"}]},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservedValue/value":{"abstract":[{"text":"The current value.","type":"text"}],"fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"value","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Value","kind":"typeIdentifier","preciseIdentifier":"s:15ObservableValue08ObservedB0C0B0xmfp"}],"type":"topic","url":"\/documentation\/observablevalue\/observedvalue\/value","role":"symbol","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/value","title":"value","kind":"symbol"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/MutableObservableValue":{"type":"topic","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"MutableObservableValue"}],"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/MutableObservableValue","title":"MutableObservableValue","navigatorTitle":[{"kind":"identifier","text":"MutableObservableValue"}],"url":"\/documentation\/observablevalue\/mutableobservablevalue","abstract":[{"text":"A mutable observable value that supports atomic in-place updates.","type":"text"}]}}}