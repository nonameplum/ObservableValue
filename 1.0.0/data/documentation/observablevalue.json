{"sections":[],"hierarchy":{"paths":[[]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"roleHeading":"Framework","modules":[{"name":"ObservableValue"}],"role":"collection","symbolKind":"module","externalID":"ObservableValue","title":"ObservableValue"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/observablevalue"]}],"primaryContentSections":[{"content":[{"text":"Overview","level":2,"type":"heading","anchor":"overview"},{"inlineContent":[{"type":"image","identifier":"ObservableValue_logo"}],"type":"paragraph"},{"text":"Overview","level":2,"type":"heading","anchor":"Overview"},{"inlineContent":[{"type":"text","text":"Swift’s structured concurrency lacks a built-in “current value” primitive. This package fills that gap with "},{"isActive":true,"type":"reference","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Synchronous snapshot","type":"text"}]},{"type":"text","text":": Read "},{"type":"reference","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/value","isActive":true},{"type":"text","text":" at any time."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Async stream of changes","type":"text"}]},{"type":"text","text":": Iterate "},{"type":"reference","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/values","isActive":true},{"type":"text","text":" from multiple tasks."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"No backpressure","type":"text"}]},{"type":"text","text":": Producers proceed immediately; slow consumers see the latest value."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Backportable","type":"text"}]},{"type":"text","text":": Works on iOS 16+ with Swift 6 toolchains."}]}]}]},{"syntax":"swift","type":"codeListing","code":["import ObservableValue","","let counter = ObservedValue(0)","","\/\/ Multiple concurrent consumers","Task { for await v in counter.values { print(\"A:\", v) } }","Task { for await v in counter.values { print(\"B:\", v) } }","","\/\/ Atomic mutation","counter.update { $0 += 1 }","","\/\/ Synchronous read","print(counter.value)  \/\/ 1"]},{"text":"Backpressure Semantics","level":3,"type":"heading","anchor":"Backpressure-Semantics"},{"inlineContent":[{"text":"Producers are never blocked. Each consumer sees the ","type":"text"},{"inlineContent":[{"type":"text","text":"latest"}],"type":"emphasis"},{"text":" value when it resumes—intermediate values may be skipped if the consumer is slower than the producer.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let state = ObservedValue(0)","var iterator = state.values.makeAsyncIterator()","","state.update { $0 = 1 }","state.update { $0 = 2 }","state.update { $0 = 3 }","","let observed = await iterator.next()  \/\/ 3 (skipped 1, 2)"]},{"text":"Backport API","level":3,"type":"heading","anchor":"Backport-API"},{"inlineContent":[{"text":"On toolchains where ","type":"text"},{"code":"AsyncSequence.Failure","type":"codeVoice"},{"text":" isn’t available, use the concrete stream:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for await value in counter.backportValues {","    print(\"value:\", value)","}"]}],"kind":"content"}],"identifier":{"url":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue","interfaceLanguage":"swift"},"kind":"symbol","abstract":[{"type":"text","text":"Current-value semantics for Swift concurrency: a multi-consumer async sequence that always yields the latest value—like Combine’s "},{"type":"codeVoice","code":"CurrentValueSubject"},{"type":"text","text":", but for async\/await."}],"topicSections":[{"identifiers":["doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/AsyncStateStream"],"anchor":"Essentials","title":"Essentials"},{"identifiers":["doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportObservableValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportMutableObservableValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservableValue","doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/MutableObservableValue"],"anchor":"Protocols","title":"Protocols"}],"references":{"doc://observablevalue.ObservableValue/documentation/ObservableValue":{"abstract":[{"type":"text","text":"Current-value semantics for Swift concurrency: a multi-consumer async sequence that always yields the latest value—like Combine’s "},{"type":"codeVoice","code":"CurrentValueSubject"},{"type":"text","text":", but for async\/await."}],"title":"ObservableValue","url":"\/documentation\/observablevalue","type":"topic","kind":"symbol","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue","role":"collection"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/BackportMutableObservableValue":{"type":"topic","role":"symbol","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportMutableObservableValue","title":"BackportMutableObservableValue","navigatorTitle":[{"text":"BackportMutableObservableValue","kind":"identifier"}],"abstract":[{"text":"A backportable mutable observable value that supports atomic in-place updates.","type":"text"}],"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BackportMutableObservableValue","kind":"identifier"}],"url":"\/documentation\/observablevalue\/backportmutableobservablevalue"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservedValue/values":{"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/values","url":"\/documentation\/observablevalue\/observedvalue\/values","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"values","kind":"identifier"},{"text":": ","kind":"text"},{"text":"AsyncStateStream","preciseIdentifier":"s:15ObservableValue16AsyncStateStreamV","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"Value","preciseIdentifier":"s:15ObservableValue08ObservedB0C0B0xmfp","kind":"typeIdentifier"},{"text":">","kind":"text"}],"type":"topic","abstract":[{"type":"text","text":"An async sequence of value changes."}],"kind":"symbol","title":"values","role":"symbol"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/MutableObservableValue":{"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/MutableObservableValue","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"MutableObservableValue","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MutableObservableValue","kind":"identifier"}],"url":"\/documentation\/observablevalue\/mutableobservablevalue","abstract":[{"text":"A mutable observable value that supports atomic in-place updates.","type":"text"}],"type":"topic","title":"MutableObservableValue"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservedValue":{"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue","type":"topic","kind":"symbol","role":"symbol","title":"ObservedValue","abstract":[{"text":"A thread-safe container that holds a current value and broadcasts changes to multiple async consumers.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"ObservedValue"}],"url":"\/documentation\/observablevalue\/observedvalue","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ObservedValue"}]},"ObservableValue_logo":{"alt":"ObservableValue logo","type":"image","identifier":"ObservableValue_logo","variants":[{"traits":["1x","light"],"url":"\/images\/observablevalue.ObservableValue\/ObservableValue_logo.png"}]},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservableValue":{"abstract":[{"type":"text","text":"A read-only observable value that exposes the current snapshot and an opaque async sequence of changes."}],"url":"\/documentation\/observablevalue\/observablevalue","navigatorTitle":[{"text":"ObservableValue","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ObservableValue","kind":"identifier"}],"type":"topic","title":"ObservableValue","role":"symbol","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservableValue","kind":"symbol"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/ObservedValue/value":{"abstract":[{"type":"text","text":"The current value."}],"role":"symbol","type":"topic","fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"value","kind":"identifier"},{"text":": ","kind":"text"},{"text":"Value","kind":"typeIdentifier","preciseIdentifier":"s:15ObservableValue08ObservedB0C0B0xmfp"}],"url":"\/documentation\/observablevalue\/observedvalue\/value","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue\/value","kind":"symbol","title":"value"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/AsyncStateStream":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncStateStream"}],"navigatorTitle":[{"kind":"identifier","text":"AsyncStateStream"}],"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/AsyncStateStream","abstract":[{"text":"A non-throwing async sequence that yields the latest value from an ","type":"text"},{"identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/ObservedValue","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"topic","url":"\/documentation\/observablevalue\/asyncstatestream","role":"symbol","kind":"symbol","title":"AsyncStateStream"},"doc://observablevalue.ObservableValue/documentation/ObservableValue/BackportObservableValue":{"type":"topic","identifier":"doc:\/\/observablevalue.ObservableValue\/documentation\/ObservableValue\/BackportObservableValue","url":"\/documentation\/observablevalue\/backportobservablevalue","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BackportObservableValue","kind":"identifier"}],"navigatorTitle":[{"text":"BackportObservableValue","kind":"identifier"}],"abstract":[{"text":"A read-only observable value that exposes the current snapshot and a concrete stream of changes.","type":"text"}],"role":"symbol","kind":"symbol","title":"BackportObservableValue"}}}